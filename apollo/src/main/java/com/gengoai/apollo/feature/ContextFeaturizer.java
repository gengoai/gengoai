/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.gengoai.apollo.feature;

import com.gengoai.apollo.data.observation.Observation;
import com.gengoai.apollo.data.observation.VariableCollectionSequence;
import com.gengoai.apollo.data.observation.VariableList;
import lombok.NonNull;

import java.io.Serializable;
import java.util.List;

/**
 * <P>A feature extractor that allows for the extraction of contextual features, i.e. using features from previous and
 * subsequent examples. Context features are defined using the feature prefix and a relative offset to the current
 * example as follows:</P>
 * <code>
 * PREFIX[relative_offset]
 * </code>
 * <p>
 * where relative offset is an integer with a negative representing to the left, optional positive sign representing to
 * the right, and 0 representing the current example. A more concrete example is:
 * </p>
 * <code>
 * WORD[-1]|POS[-1]|WORD[0]|WORD[+1]
 * </code>
 * <p>
 * in which we declare a feature made up of the previous <code>WORD</code> and <code>POS</code>, the current
 * <code>WORD</code>, and the next <code>WORD</code>. As illustrated in the example multiple prefixes can be specified
 * for a feature using a pipe <code>|</code> to separate. The contextual patterns generate boolean features in the
 * following form:
 * </p>
 * <code>
 * PREFIX1[relative_offset]|PREFIX2[relative_offset]=SUFFIX1|SUFFIX2
 * </code>
 * <p>
 * Contextual features are generated by iterating over the examples in a sequence using a {@link ContextualIterator},
 * which will return dummy beginning of sequence and end of sequence features when needed. These can be ignored and no
 * features generated if the context does not exist, by prepending a tilde <code>~</code> to the pattern, e.g.
 * <code>~WORD[-1]|WORD[0]</code>, will only create features if <code>WORD[-1]</code> exists.
 * </p>
 * <p>
 * ContextFeaturizers are required to be used in conjunction with {@link Featurizer}s when converting input data into
 * {@link Observation}s. This is accomplished by creating a {@link Featurizer} and then calling {@link
 * Featurizer#withContext(String[])}.
 * </p>
 * <p>In addition contextual features can be defined using the following operators:</p>
 * <ul>
 *    <li><code>~</code>: Strict - will only create a feature if all elements are found, e.g.
 *    <code>~WORD[-1]|WORD[0]</code> will only create a feature if both <code>WORD[-1]</code> and <code>WORD[0]</code>
 *    represent valid offsets (not the first word in a sequence)</li>
 *    <li><code>[min, max]</code>: Range - generates unique features for each prefix in the range <code>min</code> to
 *    <code>max</code>, .e.g. <code>WORD[-2,-1]|WORD[0]</code> will generate the features <code>WORD[-2]|WORD[0]</code>
 *    and <code>WORD[-1]|WORD[0]</code>.</li>
 *    <li><code>&lt;min, max&gt;</code>: NGram - generates NGrams from <code>min</code> to <code>max</code>. Works in
 *    conjunction with ranges, e.g. <code>&lt;1,2&gt;WORD[-2,-1]|WORD[0]</code> will generate the features
 *    <code>WORD[-2]|WORD[0]</code>, <code>WORD[-1]|WORD[0]</code>, and <code>WORD[-2]|WORD[-1]|WORD[0]</code></li>
 * </ul>
 *
 * @param <I> the input type parameter
 * @author David B. Bracewell
 */
public abstract class ContextFeaturizer<I> implements FeatureExtractor<I>, Serializable {
   private static final long serialVersionUID = 1L;

   public static <I> ContextFeaturizer<I> chain(@NonNull List<ContextFeaturizer<? super I>> featurizers) {
      return new ChainedContextFeaturizer<>(featurizers);
   }

   @Override
   public final VariableList extractObservation(@NonNull I input) {
      throw new UnsupportedOperationException();
   }

   private static class ChainedContextFeaturizer<I> extends ContextFeaturizer<I> {
      private static final long serialVersionUID = 1L;
      private final List<ContextFeaturizer<? super I>> contextFeaturizers;

      private ChainedContextFeaturizer(List<ContextFeaturizer<? super I>> contextFeaturizers) {
         this.contextFeaturizers = contextFeaturizers;
      }

      @Override
      public VariableCollectionSequence contextualize(VariableCollectionSequence sequence) {
         for (ContextFeaturizer<? super I> contextFeaturizer : contextFeaturizers) {
            sequence = contextFeaturizer.contextualize(sequence);
         }
         return sequence;
      }

      @Override
      public String toString() {
         StringBuilder builder = new StringBuilder("ContextualFeatures\n");
         for (ContextFeaturizer<? super I> contextFeaturizer : contextFeaturizers) {
            builder.append("\t").append(contextFeaturizer).append("\n");
         }
         return builder.toString();
      }

   }

}//END OF ContextFeaturizer
